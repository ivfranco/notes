Useful links:
    - https://support.wiley.com/s/article/reversing-secrets-of-reverse-engineering-missing-files
        main archive of book resources
    - https://www.wiley.com/en-us/Reversing%3A+Secrets+of+Reverse+Engineering+-p-9780764574818
        Errata and other book resources 
    - https://www.felixcloutier.com/x86/index.html
        x86_64 instruction reference
    - https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf
        x86_64 cheat sheet
    - https://wiki.osdev.org/
        OSDev wiki

2. Low-level software
p43, Errata: `char szWelcome` should be `char *szWelcome`
when declared as
    char *szWelcome = " .. "
the string will appear in .data section of the ELF executable, however
    const char *szWelcome = " .. "
will appear in (more approperate) .rodata section of the executable.
both compiled with non-optimizing gcc 8.3.0, content of data sections can be printed with 
    readelf -x [.data|.rodata] <FILE_PATH>

p45, x86_64 architecture additionally have 8 general purpose registers
    r8, r9, .., r15
the corresponding lower 32/16/8-bit register names are 
    r8d, r9d, .., r15d // d -> double (word)
    r8w, r9w, .., r15w // w -> a word, as in Intel 8086, the chip that kicked off x86
    r8b, r9b, .., r15b // b -> byte
the original 8 general purpose registers are extended to 64-bit as
    eax -> rax, ebx -> rbx, ..

p50, another common arithmetic instruction used by most optimized compilers is
    LEA, <mem>, <reg>
which write the _address_ of <mem> to <reg>, because of how expressive x86 memory address
expressions are LEA can be used to compute a multiply and up to two additions as a single operation,
for example 
    LEA, [RBX + RSI * 8], EDI
computes (RBX + 8 * RSI) and store it in EDI

p50, TEST instruction is emitted more frequently by gcc, while CMP performs a subtraction TEST 
performs a bitwise AND on the two operands

the EFLAGS register can be directly manipulated by x86 instructions:
    LAHF:   load flags into AH (9 - 16th least significant bits of RAX)
    SAHF:   set flags into AH
    PUSHF:  push flags onto stack
    POPF:   pop flags from stack into ELFAGS register
interestingly the first two instructions are removed in 64-bit mode for the first few 64-bit product
lines by Intel and AMD but later put back

p53, "DWORD PTR" is a size directive, it indicates the size of the data pointed by the memory
address therefore forces the operand to be treated as a pointer to data of certain size, in this
case
    push DWORD PTR [esp + 0x24]
pushes 32 bit (a DWORD) pointed by [esp + 0x24] to the stack. The four size directives in x86 are
    QWORD (64-bit), DWORD (32-bit), WORD (16-bit) and BYTE (8-bit)

p59, the gcc options producing only non-preprocessed listing file is
    gcc -E -fdirectives-only -o <LISTING_PATH> <SOURCE_PATH>
the rustc options producing assembly file is
    rustc --emit asm -C llvm-args="--x86-asm-syntax=intel" <SOURCE_PATH>

3. Windows Fundamentals
Win32 APIs _used to_ follow a cryptic flavor of the Hungarian notation:
    https://learn.microsoft.com/en-us/windows/win32/learnwin32/windows-coding-conventions

p72, narrator: "He didn't update his book." 
Good news is most of the innovative 64-bit desktop architectures didn't survive the competition.
One of the two modern architecture supported by modern Windows, x86_64, is strictly backward
compatible with x86, hence this book is still relevant after all these years.

p73, the speed gap between drives and physical memory narrowed quite a lot recently, a cutting edge
NVMe SSD operates at 7GB/s reading, only a magnitude lower than high end DDR5 memory (~70GB/s), as a
result SSDs are much more feasible as paging storages now.

p88, found an in-depth explanation of the initialization process, including calls into the native
APIs, but not sure whether it's describing Windows NT or another OS with a similar API since the
author referenced multiple times actual source code paths to these APIs which shouldn't be
available:
    https://www.cs.miami.edu/home/burt/journal/NT/processinit.html

p91, "Microsoft wonâ€™t be so concerned about developers using the native API and will soon publish
some level of documentation for it." They didn't.

p91, Zw has no meaning, it's chosen solely to avoid name conflict:
    https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/what-does-the-zw-prefix-mean-

p96, the first method is the ordinary dynamic linking, the second method requires the programmer to
manually load the dll with LoadLibrary then search the header with GetProcAddress, also the callee
must be explicitly exported with __declspec(dllexport) keyword or a DEF file.

p101, reference of PE format:
    https://learn.microsoft.com/en-us/windows/win32/debug/pe-format
Thread Local Storage Table: each thread when initialized is assigned a TLS (Thread Local Storage)
    data area, a TLS index and an entry in the TLS array pointing to its TLS data area, for each
    variable declared as 
        // C
        __declspec (thread) int x = 0;
        // Rust
        thread_local! { 
            // currently immutable only because of lifetime complications
            static x: i32 = 0;
        }
    there's a TLS data object at some fixed offset in the TLS data area, the same binary code
    therefore is able to access different memory location based on the current thread.

p105, that means exception would be thousands of times slower than return code as exception handling
has to go through the system call interface. It's always 

p107, line by line explanation of the code:
00411F8A push   ExceptionHandler
    push the pointer to the exception handler onto stack
00411F8F mov    eax, dword ptr fs:[00000000h]
    fs:[00000000h] fetches location 0x0 from the x86 FS segment instead of the default ds segment
    ([<ADDRESS>] is shorthand of ds:[<ADDRESS>]), the FS segment doesn't have hardware defined
    meaning, in WinNT FS:[0x0] points to the current head of the exception handler list
00411F95 push   eax
    push the old head to the stack
00411F96 mov    dword ptr fs:[0], esp
    stack in x86 grows downwards, the current state of stack is:
        esp+0x0     Ptr32   FS:[0x0] ;old head
        esp+0x4     Ptr32   ExceptionHandler
    thus esp points to a valid _EXCEPTION_REGISTRATN_RECORD struct


p107, again
0411F83 push 0FFFFFFFFh
00411F85 push 425090h
    addresses to two different exception handlers 
00411F8A push offset @ILT+420(__except_handler3) (4111A9h)
    __except_handler3 is part of the C++ runtime, therefore address to it is located in the ILT
    (import lookup table)
00411F8F mov eax,dword ptr fs:[00000000h]
00411F95 push eax
    push old head
00411F96 mov dword ptr fs:[0],esp
    the current state of stack is:
        esp+0x0     Ptr32   FS:[0x0] ;old head
        esp+0x4     Ptr32   __except_handler3
        esp+0x8     Ptr32   425090h
        esp+0xc     Ptr32   0FFFFFFFFh
    __except_handler3 when called would somehow delegate exceptions to the two exception handlers

4. Reversing Tools
The major addition to the tool scene is Ghidra released by NSA in 2019, an open-source and free
alternative to IDA pro. It's a nearly complete toolkit of reverse engineering: disassembly,
decompilation, debugging, patching, header dumping, etc. Its decompiler can incrementally improve
the output on user inputs including type hints, data layouts and loop structure.
Video series using Ghidra to reverse engineer WannaCry ransomware:
    part 1: https://www.youtube.com/watch?v=Sv8yu12y5zM
    part 2: https://www.youtube.com/watch?v=Q90uZS3taG0
    part 3: https://www.youtube.com/watch?v=ru5VzUigKqw

wrestool is a command-line tool to list and extract resources (embedded binaries) from PE
executables.

llvm-readobj from LLVM toolchain is a tool similar to readelf but supports a range of executable
formats, including PE32/PE32+ on WinNT and Mach-O on OSX.

5. Beyond the Documentation
p147, x86 real and protected mode memory segments:
    CS: code segment, pointed by CS register
    DS: data segment, default, points to heap
    SS: stack segment, manipulated by PUSH and POP, pointed by ESP and EBP
    ES: extra segment, used by string instructions (e.g STOS and MOVS)
    FS: no hardware use, points to TIB on 32-bit WinNT
    GS: no hardware use, points to TIB on 64-bit WinNT
on x86_64 however, base of all segments but FS and GS are _ignored_ and treated as 0

p147, Errata: cdecl and stdcall has the same parameter order right-to-left.
https://learn.microsoft.com/en-us/cpp/cpp/argument-passing-and-naming-conventions
identify x86 calling conventions
cdecl: RET has no operand
    all parameters on stack
    parameters on stack pushed right-to-left
    caller restores stack
fastcall: ECX or EDX are used before initialization in function body
    first two parameters passed in ECX and EDX, rest on stack
    parameters on stack pushed right-to-left
    callee restores the stack
stdcall: RET has operand & is not fastcall
    all parameters on stack
    parameters on stack pushed right-to-left
    callee restores stack
thiscall: always decorated with class name and parameter type
    this pointer passed via ECX
    parameters on stack pushed right-to-left
    callee restores stack
fastcc: anything goes (https://llvm.org/docs/LangRef.html#callingconv)
    calling convention used by LLVM for non-interoperable code, uses _whatever trick_ possible for
    faster code, ABI unstable

x86_64 has only two calling conventions (https://wiki.osdev.org/Calling_Conventions): 
SystemV X86_64 (every platform besides Windows):
    RDI, RSI, RDX, RCX, R8, R9 then stack
    parameters on stack pushed right-to-left
    caller restores stack
    return value in RAX and RDX 
Microsoft x64:
    RCX, RDX, R8, R9 then stack
    parameters on stack pushed right-to-left
    caller restores stack
    return value in RAX 

p147, RtlInitializeGenericTable:
    7C921A39 MOV EDI,EDI
        https://devblogs.microsoft.com/oldnewthing/20110921-00/?p=9583
        a two-byte NOP inserted as a hot-patch point, replaced by a 2-byte jmp instruction when the
        function is hot-patched
    7C921A3B PUSH EBP
    7C921A3C MOV EBP,ESP
        prologue, store and set up ebp
        state of the stack:
            esp+0x0     OLD_EBP
            esp+0x4     RETURN_ADDRESS
            esp+0x8     PARAM_1
            ...
    7C921A3E MOV EAX,DWORD PTR SS:[EBP+8]
        EAX = PARAM_1
    7C921A41 XOR EDX,EDX
        EDX = 0
    7C921A43 LEA ECX,DWORD PTR DS:[EAX+4]
        ECX = PARAM_1 + 0x4
    7C921A46 MOV DWORD PTR DS:[EAX],EDX
        [PARAM_1] = 0
        PARAM_1 is a pointer
    7C921A48 MOV DWORD PTR DS:[ECX+4],ECX
        [PARAM_1+0x8] = PARAM_1 + 0x4
    7C921A4B MOV DWORD PTR DS:[ECX],ECX
        [PARAM_1+0x4] = PARAM_1 + 0x4
    7C921A4D MOV DWORD PTR DS:[EAX+C],ECX
        [PARAM_1+0xC] = PARAM_1 + 0x4
    7C921A50 MOV ECX,DWORD PTR SS:[EBP+C]
    7C921A53 MOV DWORD PTR DS:[EAX+18],ECX
        [PARAM_1+0x18] = PARAM_2
    7C921A56 MOV ECX,DWORD PTR SS:[EBP+10]
    7C921A59 MOV DWORD PTR DS:[EAX+1C],ECX
        [PARAM_1+0x1C] = PARAM_3
    7C921A5C MOV ECX,DWORD PTR SS:[EBP+14]
    7C921A5F MOV DWORD PTR DS:[EAX+20],ECX
        [PARAM_1+0x20] = PARAM_4
    7C921A62 MOV ECX,DWORD PTR SS:[EBP+18]
    7C921A65 MOV DWORD PTR DS:[EAX+14],EDX
        [PARAM_1+0x14] = 0
    7C921A68 MOV DWORD PTR DS:[EAX+10],EDX
        [PARAM_1+0x10] = 0
    7C921A6B MOV DWORD PTR DS:[EAX+24],ECX
        [PARAM_1+0x24] = PARAM_5
    7C921A6E POP EBP
    7C921A6F RET 14
        epilogue
this function initializes a structure that looks like:
    struct TABLE
    {
        UNKNOWN4        Member1; // = 0
        UNKNOWN_PTR32   Member2; // = &Member2
        UNKNOWN_PTR32   Member3; // = &Member2
        UNKNOWN_PTR32   Member4; // = &Member2
        UNKNOWN4        Member5; // = 0
        UNKNOWN4        Member6; // = 0
        UNKNOWN4        Member7; // = PARAM_2
        UNKNOWN4        Member8; // = PARAM_3
        UNKNOWN4        Member9; // = PARAM_4
        UNKNOWN4        Member10; // = PARAM_5
    }
Ghidra is able to automatically deduct the above type definition from the code of
RtlInitializeGenericTable, amazing

p152, RtlNumberGenericTableElements:
    7C923FD2 PUSH EBP
    7C923FD3 MOV EBP,ESP
        prologue
    7C923FD5 MOV EAX,DWORD PTR [EBP+8]
        EAX = PARAM_1
    7C923FD8 MOV EAX,DWORD PTR [EAX+14]
        EAX = *(PARAM_1 + 0x14)
    7C923FDB POP EBP
    7C923FDC RET 4
        EAX is returned
Member6 (PARAM_1 + 0x14) is the number of elements in the table, its type should be UInt32.

p152, RtlIsGenericTableEmpty:
    7C92715B PUSH EBP
    7C92715C MOV EBP,ESP
        prologue
    7C92715E MOV ECX,DWORD PTR [EBP+8]
        ECX = PARAM_1
    7C927161 XOR EAX,EAX
        EAX = 0
    7C927163 CMP DWORD PTR [ECX],EAX
    7C927165 SETE AL
        if (*PARAM_1 == 0) EAX = 1;
    7C927168 POP EBP
    7C927169 RET 4
        return EAX
Member1 is a pointer, non-null when the table has elements.

p154, void* RtlGetElementGenericTable(TABLE *Table, UInt32 index):
    7C9624E0 PUSH EBP
    7C9624E1 MOV EBP,ESP                    ; prologue
    7C9624E3 MOV ECX,DWORD PTR [EBP+8]      ; ECX = Table
    7C9624E6 MOV EDX,DWORD PTR [ECX+14]     ; EDX = Table->TotalElements
    7C9624E9 MOV EAX,DWORD PTR [ECX+C]      ; EAX = Table->LastElementFound
    7C9624EC PUSH EBX
    7C9624ED PUSH ESI                       ; callee saved registers
    7C9624EE MOV ESI,DWORD PTR [ECX+10]     ; ESI = Table->LastIndexFound
    7C9624F1 PUSH EDI                       ; callee saved registers
    7C9624F2 MOV EDI,DWORD PTR [EBP+C]      ; EDI = index
    7C9624F5 CMP EDI,-1
    7C9624F8 LEA EBX,DWORD PTR [EDI+1]      ; EBX = index + 1
    7C9624FB JE SHORT ntdll.7C962559        ; SHORT i.e. intramodule jump
                                            ; if (index == 0xFFFFFFFF)
                                            ;   jump to error_exit
    7C9624FD CMP EBX,EDX                    ; if (index + 1 > Table->TotalElements)
    7C9624FF JA SHORT ntdll.7C962559        ;   jump to error_exit
    7C962501 CMP ESI,EBX                    ; if (Table->LastIndexFound == index + 1) {
    7C962503 JE SHORT ntdll.7C962554        ;   jump to skip_header
                                            ; if (Table->LastIndexFound < index + 1) {
    7C962505 JBE SHORT ntdll.7C96252B       ;   jump to forward_search_1
    7C962507 MOV EDX,ESI                    ; EDX = Table->LastIndexFound
    7C962509 SHR EDX,1                      ; EDX = Table->LastIndexFound / 2
    7C96250B CMP EBX,EDX                    ; if (index + 1 <= Table->LastIndexFound / 2)
    7C96250D JBE SHORT ntdll.7C96251B       ;   jump to forward_search_2
    7C96250F SUB ESI,EBX                    ; ESI = Table->LastIndexFound - index - 1
                                            ; if (Table->LastIndexFound == index + 1)
    7C962511 JE SHORT ntdll.7C96254E        ;   jump to set_cache
loop_1:                                     ; while (ESI > 0) {
    7C962513 DEC ESI                        ;   ESI = ESI - 1
    7C962514 MOV EAX,DWORD PTR [EAX+4]      ;   EAX = EAX->PrevElement
                                            ; Table->LastElementFound points to a 3-pointer header structure, 
                                            ; EAX+0x4 points to the second entry of the 3 pointers,
                                            ; these structures form a linked list 
    7C962517 JNZ SHORT ntdll.7C962513       ; }
    7C962519 JMP SHORT ntdll.7C96254E       ; jump to set_cache
forward_search_2:
    7C96251B TEST EBX,EBX                   
    7C96251D LEA EAX,DWORD PTR [ECX+4]      ; EAX = Table->LastElement
    7C962520 JE SHORT ntdll.7C96254E        ; if (index + 1 == 0) jump to set_cache
    7C962522 MOV EDX,EBX                    ; EDX = index + 1
loop_4:                                     ; while (EDX > 0) {
    7C962524 DEC EDX                        ;   EDX -= 1
    7C962525 MOV EAX,DWORD PTR [EAX]        ;   EAX = EAX->NextElement
    7C962527 JNZ SHORT ntdll.7C962524       ; follow the first pointer in 3-pointer header
                                            ; the linked list must be circular
                                            ; } 
    7C962529 JMP SHORT ntdll.7C96254E       ; jump to set_cache
forward_search_1:
    7C96252B MOV EDI,EBX                    ; EDI = index + 1
    7C96252D SUB EDX,EBX                    ; EDX = Table->TotalElements - index - 1
    7C96252F SUB EDI,ESI                    ; EDI = index + 1 - Table->LastIndexFound
                                            ; distance from index to the last found element
    7C962531 INC EDX                        ; EDX = Table->TotalElements - index
                                            ; distance from index to the last element in table
    7C962532 CMP EDI,EDX                    ; if (EDI > EDX)
    7C962534 JA SHORT ntdll.7C962541        ;   jump to backward_search_1
    7C962536 TEST EDI,EDI                   ; if (EDI == 0)
    7C962538 JE SHORT ntdll.7C96254E        ;   jump to set_cache
loop_3:                                     ; while (EDI > 0) {
    7C96253A DEC EDI                        ;   EDI -= 1
    7C96253B MOV EAX,DWORD PTR [EAX]        ;   EAX = EAX->NextElement
                                            ; follow the first pointer in the 3-pointer structure
    7C96253D JNZ SHORT ntdll.7C96253A       ; }
    7C96253F JMP SHORT ntdll.7C96254E       ; jump to set_cache
backward_search_1;
    7C962541 TEST EDX,EDX                   
    7C962543 LEA EAX,DWORD PTR [ECX+4]      ; EAX = Table->LastElement
    7C962546 JE SHORT ntdll.7C96254E        ; if (EDX == 0) jump to set_cache
loop_2:                                     ; while (EDX > 0) {
    7C962548 DEC EDX                        ;   EDX -= 1;
    7C962549 MOV EAX,DWORD PTR [EAX+4]      ;   EAX = EAX->PrevElement
    7C96254C JNZ SHORT ntdll.7C962548       ; follow the second pointer in the 3-pointer header
                                            ; }
set_cache:
    7C96254E MOV DWORD PTR [ECX+C],EAX      ; Table->LastElementFound = EAX
    7C962551 MOV DWORD PTR [ECX+10],EBX     ; Table->LastIndexFound = EBX
skip_header:
    7C962554 ADD EAX,0C                     ; EAX = EAX + 0xC, skips the 3-pointer header
    7C962557 JMP SHORT ntdll.7C96255B       ; jump to exit
error_exit:
    7C962559 XOR EAX,EAX                    ; EAX = NULL
exit:
    7C96255B POP EDI                        ; epilogue
    7C96255C POP ESI                        ; restore callee saved registers
    7C96255D POP EBX                        
    7C96255E POP EBP                        
    7C96255F RET 8                          
high level description of void* RtlGetElementGenericTable(TABLE *Table, UInt32 index):
    if index + 1 is in range [0, Table->LastIndexFound / 2]:
        traverse forward from Table->LastElement
    if index + 1 is in range (Table->LastIndexFound / 2, Table->LastIndexFound]:
        traverse backward from Table->LastElementFound
    if index + 1 is in range (Table->LastIndexFound, Table->TotalElements]:
        if index + 1 is closer to Table->LastIndexFound:
            traverse forward from Table->LastElementFound
        if index + 1 is closer to Table->TotalElements
            traverse backward from Table->LastElement
    set Table->LastElementFound, Table->LastIndexFound to the search results
    return pointer to the data section of the listed list node found

p169, UNKNOWN4 RtlInsertElementGenericpTable {
    TABLE *pTable,
    PVOID ElementData,
    UInt32 ElementLength,
    UInt8 *pResult,
}
    7C924DC0 PUSH EBP                   ; prologue
    7C924DC1 MOV EBP,ESP            
    7C924DC3 PUSH EDI
    7C924DC4 MOV EDI,DWORD PTR [EBP+8]  ; EDI = pTable, 1st parameter
    7C924DC7 LEA EAX,DWORD PTR [EBP+8]  ; EAX = EBP + 0x8
    7C924DCA PUSH EAX                   ; 3rd parameter
    7C924DCB PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C924DCE CALL ntdll.7C92147B
    7C924DD3 PUSH EAX                   ; return value, 6th parameter
    7C924DD4 PUSH DWORD PTR [EBP+8]     ; mutated by ntdll.7C92147B, 5th parameter
    7C924DD7 PUSH DWORD PTR [EBP+14]    ; pResult, 4th parameter
    7C924DDA PUSH DWORD PTR [EBP+10]    ; ElementLength, 3rd parameter
    7C924DDD PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C924DE0 PUSH EDI                   ; pTable, 1st parameter
    7C924DE1 CALL ntdll.7C924DF0        ; return value returned
    7C924DE6 POP EDI                    ; epilogue
    7C924DE7 POP EBP
    7C924DE8 RET 10

p171, int RtlLocateNodeGenericpTable(
    TABLE *pTable, 
    PVOID DataToLocate, 
    NODE **ppNodeFound
)
                                        ; EDI = pTable, passed in register
    7C92147B MOV EDI,EDI                ; hot patch point
    7C92147D PUSH EBP                   ; prologue
    7C92147E MOV EBP,ESP
    7C921480 PUSH ESI
    7C921481 MOV ESI,DWORD PTR [EDI]    ; pNode = pTable->Root
    7C921483 TEST ESI,ESI               ; if (pTable->Root == NULL)
    7C921485 JE ntdll.7C924E8C          ;   jump to error
loop_1:                                 
                                        ; pNode is changed every loop
    7C92148B LEA EAX,DWORD PTR [ESI+18] ; EAX = pNode->data
    7C92148E PUSH EAX                   ; 3rd parameter
    7C92148F PUSH DWORD PTR [EBP+8]     ; DataToLocate, 2nd parameter
    7C921492 PUSH EDI                   ; pTable, 1st parameter
    7C921493 CALL DWORD PTR [EDI+18]    ; pTable->Comparator (Member_7)
    7C921496 TEST EAX,EAX               ; if (comparison_result == 0)
    7C921498 JE ntdll.7C924F14          ;   jump to right_branch
    7C92149E CMP EAX,1                  ; if (comparison_result != 1)
    7C9214A1 JNZ SHORT ntdll.7C9214BB   ;   jump to set_ret_1
    7C9214A3 MOV EAX,DWORD PTR [ESI+8]  ; EAX = pNode->LeftChild
    7C9214A6 TEST EAX,EAX               ; if (EAX != NULL)
    7C9214A8 JNZ ntdll.7C924F22         ;   jump to follow_right_branch
    7C9214AE PUSH 3
pop_ret:
    7C9214B0 POP EAX                    ; possible return values are 0, 1, 2, 3
                                        ; 0: error code
                                        ; 1: equal
                                        ; 2: greater (DataToLocate > pNode->data)
                                        ; 3: lesser
set_out_var:
    7C9214B1 MOV ECX,DWORD PTR [EBP+C]  ; ECX = ppNodeFound
    7C9214B4 MOV DWORD PTR [ECX],ESI    ; *ppNodeFound = pNode
exit:
    7C9214B6 POP ESI                    ; epilogue
    7C9214B7 POP EBP
    7C9214B8 RET 8
set_ret_1:
    7C9214BB XOR EAX,EAX
    7C9214BD INC EAX                    ; EAX = 1
    7C9214BE JMP SHORT ntdll.7C9214B1   ; jump to set_out_var
error:
    7C924E8C XOR EAX,EAX                ; EAX = 0
    7C924E8E JMP ntdll.7C9214B6         ; jump to exit
right_branch:
    7C924F14 MOV EAX,DWORD PTR [ESI+4]  ; EAX = pNode->RightChild
    7C924F17 TEST EAX,EAX               ; if (EAX != NULL)
    7C924F19 JNZ SHORT ntdll.7C924F22   ;   jump to follow_right_branch
    7C924F1B PUSH 2
    7C924F1D JMP ntdll.7C9214B0         ; jump to pop_ret
follow_right_branch:
    7C924F22 MOV ESI,EAX                ; pNode = pNode->RightChild
    7C924F24 JMP ntdll.7C92148B         ; jump to loop_1

p180, RtlRealInsertElementWorker
UNKNOWN RtlRealInsertElementWorker {
    TABLE *pTable,
    PVOID ElementData,
    UInt32 ElementSize,
    UInt8 *pResult,
    NODE *pNode,
    UInt32 SearchResult,
}
    7C924DF0 MOV EDI,EDI                ; prologue
    7C924DF2 PUSH EBP                   
    7C924DF3 MOV EBP,ESP
    7C924DF5 CMP DWORD PTR [EBP+1C],1   
    7C924DF9 PUSH EBX
    7C924DFA PUSH ESI
    7C924DFB PUSH EDI
    7C924DFC JE ntdll.7C935D5D          ; if (SearchResult == 1)
                                        ;   jump to splay_parent
    7C924E02 MOV EDI,DWORD PTR [EBP+10] ; EDI = ElementSize
    7C924E05 MOV ESI,DWORD PTR [EBP+8]  ; ESI = pTable
    7C924E08 LEA EAX,DWORD PTR [EDI+18] ; EAX = ElementSize + 0x18
                                        ; 0x18 is size of node header? 
    7C924E0B PUSH EAX                   ; ElementSize + 0x18, 2nd parameter
    7C924E0C PUSH ESI                   ; pTable, 1st parameter
    7C924E0D CALL DWORD PTR [ESI+1C]    ; pTable->Allocator (Member 8)
    7C924E10 MOV EBX,EAX                ; EBX = (Node *)return_value
    7C924E12 TEST EBX,EBX               ; if (node == NULL)
    7C924E14 JE ntdll.7C94D4BE          ;   jump to set_presult_false
    7C924E1A AND DWORD PTR [EBX+4],0    ; *(EBX + 0x4) = 0u32
    7C924E1E AND DWORD PTR [EBX+8],0    ; *(EBX + 0x8) = 0u32
    7C924E22 MOV DWORD PTR [EBX],EBX    ; *EBX = EBX
    7C924E24 LEA ECX,DWORD PTR [ESI+4]  ; ECX = &pTable->LLHead
    7C924E27 MOV EDX,DWORD PTR [ECX+4]  ; EDX = pTable->Member3
    7C924E2A LEA EAX,DWORD PTR [EBX+C]  ; EAX = EBX + 0xC
    7C924E2D MOV DWORD PTR [EAX],ECX    ; *(EBX + 0xC) = &pTable->LLHead
    7C924E2F MOV DWORD PTR [EAX+4],EDX  ; *(EBX + 0x10) = pTable->Member3
    7C924E32 MOV DWORD PTR [EDX],EAX    ; *pTable->Member3 = EBX + 0xC
    7C924E34 MOV DWORD PTR [ECX+4],EAX  ; pTable->Member3 = EBX + 0xC
    7C924E37 INC DWORD PTR [ESI+14]     ; pTable->TotalElements += 1
    7C924E3A CMP DWORD PTR [EBP+1C],0   ; if (SearchResult == 0)
    7C924E3E JE SHORT ntdll.7C924E88    ;   jump to set_root
    7C924E40 CMP DWORD PTR [EBP+1C],2
    7C924E44 MOV EAX,DWORD PTR [EBP+18] ; EAX = pNode
    7C924E47 JE ntdll.7C924F0C          ; if (SearchResult == 2)
                                        ;   jump to right_child
    7C924E4D MOV DWORD PTR [EAX+8],EBX  ; pNode->LeftChild = EBX
set_parent:
    7C924E50 MOV DWORD PTR [EBX],EAX    ; EBX->Parent = pNode
memcpy:
    7C924E52 MOV ESI,DWORD PTR [EBP+C]  ; ESI = ElementData
    7C924E55 MOV ECX,EDI
    7C924E57 MOV EAX,ECX                ; EAX = ElementSize
    7C924E59 SHR ECX,2                  ; ECX = ElementSize / 4
    7C924E5C LEA EDI,DWORD PTR [EBX+18] ; EDI = &pNode->data
    7C924E5F REP MOVS DWORD PTR ES:[EDI],DWORD PTR [ESI]
                                        ; for (; ECX > 0; ECX--) {
                                        ;   *(UInt32 *)EDI = *(UInt32 *)ESI
                                        ;   EDI += 4
                                        ;   ESI += 4
                                        ; }
    7C924E61 MOV ECX,EAX
    7C924E63 AND ECX,3                  ; ECX = ElementSize % 4
    7C924E66 REP MOVS BYTE PTR ES:[EDI],BYTE PTR [ESI]
                                        ; for (; ECX > 0; ECX--) {
                                        ;   *EDI = *(BYTE *)ESI
                                        ;   EDI += 1
                                        ;   ESI += 1
                                        ; }
    7C924E68 PUSH EBX                   ; pNewNode, 1st paremter
call_splay:
    7C924E69 CALL ntdll.RtlSplay        ; EAX = RETURN_VALUE
    7C924E6E MOV ECX,DWORD PTR [EBP+8]  ; ECX = pTable
    7C924E71 MOV DWORD PTR [ECX],EAX    ; pTable->Root = RETURN_VALUE
    7C924E73 MOV EAX,DWORD PTR [EBP+14] ; EAX = pResult
    7C924E76 TEST EAX,EAX               ; if (pResult != NULL)
    7C924E78 JNZ ntdll.7C935D4F         ;   jump to set_presult_true
set_return_value:
    7C924E7E LEA EAX,DWORD PTR [EBX+18] ; EAX = pNewNode->data
exit:
    7C924E81 POP EDI                    ; epilogue
    7C924E82 POP ESI
    7C924E83 POP EBX
    7C924E84 POP EBP
    7C924E85 RET 18
set_root:
    7C924E88 MOV DWORD PTR [ESI],EBX    ; pTable->Root = EBX
    7C924E8A JMP SHORT ntdll.7C924E52   ; jump to memcpy
    7C924E8C XOR EAX,EAX
    7C924E8E JMP ntdll.7C9214B6
right_child:
    7C924F0C MOV DWORD PTR [EAX+4],EBX  ; pNode->RightChild = EBX
    7C924F0F JMP ntdll.7C924E50         ; jump to set_parent
splay_parent:
    ; not given
    ; set EBX = pNode then jump to call_splay
set_presult_true:
    ; not given
    ; set *pResult = TRUE then jump to set_return_value
set_presult_false:
    7C94D4BE MOV EAX,DWORD PTR [EBP+14] ; EAX = pResult
    7C94D4C1 TEST EAX,EAX               ; if (pResult == NULL)
    7C94D4C3 JE SHORT ntdll.7C94D4C7    ;   jump to return_null
    7C94D4C5 MOV BYTE PTR [EAX],BL      ; *pResult = FALSE
return_null:
    7C94D4C7 XOR EAX,EAX                ; EAX = NULL
    7C94D4C9 JMP ntdll.7C924E81         ; jump to exit

p185, Errata: ECX = ElementSize / 4

p190, RtlLookupElementGenericTable
    7C9215BB PUSH EBP                   ; prologue
    7C9215BC MOV EBP,ESP 
    7C9215BE LEA EAX,DWORD PTR [EBP+C]  ; EAX = EBP + 0xC
    7C9215C1 PUSH EAX                   ; 4th parameter, output
    7C9215C2 LEA EAX,DWORD PTR [EBP+8]  ; EAX = EBP + 0x8
    7C9215C5 PUSH EAX                   ; 3rd parameter, output
    7C9215C6 PUSH DWORD PTR [EBP+C]     ; PARAM_2, 2nd parameter
    7C9215C9 PUSH DWORD PTR [EBP+8]     ; PARAM_1, 1st parameter
    7C9215CC CALL ntdll.7C9215DA        
    7C9215D1 POP EBP                    ; epilogue
    7C9215D2 RET 8

p192, ntdll.7C9215DA
PVOID RtlLookupElementGenericTableWorker(
    TABLE *pTable,
    PVOID ElementData, 
    NODE **ppNode,
    int *SearchResult,
)
    7C9215DA MOV EDI,EDI                ; prologue
    7C9215DC PUSH EBP           
    7C9215DD MOV EBP,ESP
    7C9215DF PUSH ESI
    7C9215E0 MOV ESI,DWORD PTR [EBP+10] ; ESI = ppNode
    7C9215E3 PUSH EDI
    7C9215E4 MOV EDI,DWORD PTR [EBP+8]  ; EDI = pTable, 1st parameter
    7C9215E7 PUSH ESI                   ; ppNode, 3rd parameter
    7C9215E8 PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C9215EB CALL ntdll.7C92147B        ; RtlLocateNodeGenericpTable
    7C9215F0 TEST EAX,EAX
    7C9215F2 MOV ECX,DWORD PTR [EBP+14] ; ECX = SearchResult
    7C9215F5 MOV DWORD PTR [ECX],EAX    ; *SearchResult = RETURN_VALUE
    7C9215F7 JE SHORT ntdll.7C9215FE    ; if (RETURN_VALUE == 0)
                                        ;   jump to return_null
    7C9215F9 CMP EAX,1                  ; if (RETURN_VALUE == 1)
    7C9215FC JE SHORT ntdll.7C921606    ;   jump to splay
return_null:
    7C9215FE XOR EAX,EAX                ; EAX = NULL
exit:
    7C921600 POP EDI                    ; epilogue
    7C921601 POP ESI
    7C921602 POP EBP
    7C921603 RET 10
splay:
    7C921606 PUSH DWORD PTR [ESI]       ; ppNode, 1st parameter
    7C921608 CALL ntdll.RtlSplay
    7C92160D MOV DWORD PTR [EDI],EAX    ; pTable->Root = RETURN_VALUE
    7C92160F MOV EAX,DWORD PTR [ESI]
    7C921611 ADD EAX,18                 ; EAX = *ppNode + 0x18
                                        ; points to data section
    7C921614 JMP SHORT ntdll.7C921600   ; jump to exit

p193, BOOLEAN RtlDeleteElementGenericTable(
    TABLE *pTable,
    PVOID ElementData,
)
    7C924FFF MOV EDI,EDI                ; prologue
    7C925001 PUSH EBP
    7C925002 MOV EBP,ESP
    7C925004 PUSH EDI
    7C925005 MOV EDI,DWORD PTR [EBP+8]  ; EDI = pTable, 1st parameter
    7C925008 LEA EAX,DWORD PTR [EBP+C]  ; EAX = &ElementData
    7C92500B PUSH EAX                   ; 3rd parameter
    7C92500C PUSH DWORD PTR [EBP+C]     ; ElementData, 2nd parameter
    7C92500F CALL ntdll.7C92147B        ; RtlLocateNodeGenericpTable
                                        ; ElementData is overwritten with parent node header 
                                        ; rename ElementData -> pNode
                                        ; there's a 0x18 byte minimal length requirement for data?
    7C925014 TEST EAX,EAX               ; if (searchResult == 0)
    7C925016 JE SHORT ntdll.7C92504E    ;   jump to not_found
    7C925018 CMP EAX,1                  ; if (searchResult != 1)
    7C92501B JNZ SHORT ntdll.7C92504E   ;   jump to not_found
    7C92501D PUSH ESI                   ; 
    7C92501E MOV ESI,DWORD PTR [EBP+C]  ; ESI = pNode
    7C925021 PUSH ESI                   ; 2nd parameter 
    7C925022 CALL ntdll.RtlDelete       ; pTable passed in register
                                        ; returns root after splay
    7C925027 MOV DWORD PTR [EDI],EAX    ; pTable->Root = root
                                        ; remove current node from linked list
    7C925029 MOV EAX,DWORD PTR [ESI+C]  ; EAX = pNode->LLEntry->NextElement
    7C92502C MOV ECX,DWORD PTR [ESI+10] ; ECX = pNode->LLEntry->PrevElement
    7C92502F MOV DWORD PTR [ECX],EAX    ; *pNode->LLEntry->PrevElement = pNode->LLEntry->NextElement
    7C925031 MOV DWORD PTR [EAX+4],ECX  ; *pNode->LLEntry->NextElement->PrevElement = pNode->LLEntry->PrevElement
    7C925034 DEC DWORD PTR [EDI+14]     ; pTable->TotalElements -= 1
    7C925037 AND DWORD PTR [EDI+10],0   ; pTable->LastIndexFound = 0
    7C92503B PUSH ESI                   ; ElementData, 2nd parameter
    7C92503C LEA EAX,DWORD PTR [EDI+4]  
    7C92503F PUSH EDI                   ; pTable, 1st parameter
    7C925040 MOV DWORD PTR [EDI+C],EAX
    7C925043 CALL DWORD PTR [EDI+20]    ; pTable->Deallocator
    7C925046 MOV AL,1                   ; EAX = TRUE
exit_1:
    7C925048 POP ESI                    ; epilogue
exit_2:
    7C925049 POP EDI
    7C92504A POP EBP
    7C92504B RET 8
not_found:
    7C92504E XOR AL,AL                  ; EAX = FALSE
    7C925050 JMP SHORT ntdll.7C925049   ; jump to exit_2

continuously updated type definitions:
struct TABLE
{
    Node            *Member1;
    ListEntry       LLHead;
    ListEntry       *LastElementFound;
    UInt32          *LastIndexFound;
    UInt32          TotalElements;
    Comparator      *Comparator;
    Allocator       *Allocator;
    Deallocator     *Deallocator;
    UNKNOWN4        Member10;
}
struct ListEntry {
    ListEntry       *NextElement;
    ListEntry       *PrevElement;
}
struct Node {
    Node            *Parent;        // 0x0
    Node            *RightChild;    // 0x4
    Node            *LeftChild;     // 0x8
    ListEntry       LLEntry;        // 0xC
    UNKNOWN4        PARAM_5;        // 0x14
    char            data[];         // 0x18
}
// return value of Comparator is very likely an enum
// enum Ordering {
//  GT = 0;
//  LT = 1;
//  EQ = 2;
// }
typedef UInt32 (* Comparator)(TABLE *, PVOID, PVOID);
typedef PVOID (* Allocator)(TABLE *, UInt32);
typedef void (* Deallocator)(TABLE *, PVOID);

6. Deciphering File Formats
OllyDbg discontinued around 2014, the planned x64 support was never finished. x64dbg is what's
closest to a modern OllyDbg alternative on the market.  homepage: https://x64dbg.com/

p211, with the help of a feature rich reverse engineering toolkit it's easy to arrive at the same
conclusion. Ghidra for example can list all embedded strings and their memory location, which leads
to all the locations these strings are cross referenced.
Ghidra decompilation of Listing 6.4:
---CODE START---
BOOL __cdecl HashHeader(BYTE *src,BYTE *dst)

{
  BOOL ok;
  HCRYPTHASH phHash;
  DWORD dataLen;
  
  ok = CryptCreateHash((HCRYPTPROV)CRYPT_PROVIDER,CALG_MD5,0,0,&phHash);
  if (ok != FALSE) {
    ok = CryptHashData(phHash,src,0x14,0);
    if (ok != FALSE) {
      dataLen = 0x10;
      ok = CryptGetHashParam(phHash,2,dst,&dataLen,0);
      CryptDestroyHash(phHash);
      return ok;
    }
    CryptDestroyHash(phHash);
  }
  return 0;
}
---CODE END---

p214, Ghidra decompilation of Listing 6.5
---CODE START---
HCRYPTKEY __cdecl DeriveKeyFromPassword(HCRYPTPROV cryptProvider,BYTE *password)

{
  BOOL createHash_ok;
  BYTE *passwordEnd;
  BOOL hashDataOk;
  BOOL getHashParamOk;
  BOOL hashHeaderOk;
  HCRYPTKEY dummyKey;
  HCRYPTHASH hHash;
  HCRYPTKEY key;
  DWORD dataLen;
  BYTE hashVal [20];
  BYTE c;
  dword cookie;
                    /* initial value set to BB40E64Eh (3141592654, PI) */
  cookie = COOKIE;
  createHash_ok = CryptCreateHash(cryptProvider,CALG_SHA,0,0,&hHash);
  if (createHash_ok != FALSE) {
                    /* strlen */
    passwordEnd = password;
    do {
      c = *passwordEnd;
      passwordEnd = passwordEnd + 1;
    } while (c != '\0');
    hashDataOk = CryptHashData(hHash,password,(int)passwordEnd - (int)(password + 1),0);
    if (hashDataOk != 0) {
                    /* memset 0, unrolled */
      hashVal._1_4_ = 0;
      hashVal._5_4_ = 0;
      hashVal._9_4_ = 0;
      hashVal._13_4_ = 0;
      hashVal._17_2_ = 0;
      hashVal[19] = 0;
      hashVal[0] = 0;
      dataLen = 0x14;
      getHashParamOk = CryptGetHashParam(hHash,HP_HASHVAL,hashVal,&dataLen,0);
      if (getHashParamOk == 0) {
        printf("Unable to obtain MD5 hash value for file.\n");
      }
      hashHeaderOk = HashHeader(hashVal,HASH_BUFFER);
      if (hashHeaderOk != 0) {
        key = 0;
        CryptDeriveKey(cryptProvider,CALG_3DES,hHash,0,&key);
        CryptDestroyHash(hHash);
                    /* buffer overrun check */
        OverrunCheck(cookie);
        return key;
      }
    }
    CryptDestroyHash(hHash);
  }
  dummyKey = 0;
  OverrunCheck(cookie);
  return dummyKey;
}
---CODE END---

p219, decompilation of 0x004019F0:
---CODE START---
int __cdecl ListFilesInArchive(HANDLE hArchive,HCRYPTKEY key,int *totalClusters)

{
  int filesListed;
  BYTE *pByte;
  BYTE *pCluster;
  dword entries;
  DWORD clusterNumber;
  
  filesListed = 0;
  SetFilePointer(hArchive,0,(PLONG)NULL,FILE_BEGIN);
  ReadFile(hArchive,HEADER_BUFFER,0x28,&entries,(LPOVERLAPPED)NULL);
                    /* header 0xc: the first-cluster index */
  DecryptCluster(hArchive,HEADER_BUFFER._12_4_,key);
  clusterNumber = HEADER_BUFFER._12_4_;
  pCluster = CLUSTER_BUFFER;
  printf("\n   File Size    File Name\n");
  while( true ) {
    if (clusterNumber == 0) {
                    /* no block may have id = 0, must be NULL termination */
      return filesListed;
    }
                    /* first (size, file_name) entry starts at 0x8 */
    pByte = (BYTE *)((int)pCluster + 8);
    entries = 0x1a;
    do {
                    /* empty file entry is indicated by 0 number of clusters occupied */
      if (*(int *)pByte != 0) {
                    /* 0x0: 4-byte number of clusters occupied
                       0x4: ??
                       0x8: ??
                       0x14: file name
                       
                       8 bytes in each cluster is reserved by next/prev pointers? */
        printf(" %10dK    %s\n",(uint)(*(int *)pByte * (0x1008 - 0x8)) >> 10,pByte + 0x14);
        *totalClusters = *totalClusters + *(int *)pByte;
        filesListed = filesListed + 1;
      }
                    /* each entry is 0x98 (152) bytes in length
                       0x1a (26) is the biggest number of entries fits in a cluster */
      pByte = pByte + 0x98;
      entries = entries - 1;
    } while (entries != 0);
                    /* pointer to the next cluster in the file list */
    clusterNumber = *(DWORD *)pCluster;
    if (clusterNumber == 0) break;
    pCluster = DecryptCluster(hArchive,clusterNumber,key);
  }
  return filesListed;
}
---CODE END---

p221, decompilation of 0x00401030:
---CODE START---
BYTE * __cdecl DecryptCluster(HANDLE hArchive,DWORD clusterNumber,HCRYPTKEY key)

{
  uint lowLen;
  BOOL ok;
  DWORD bytesRead;
  DWORD clusterNo;
  longlong highLen;
  
                    /* the id of 0x1008 byte chunks */
  clusterNo = clusterNumber;
                    /* badly decompiled multiplication */
  highLen = (ulonglong)(clusterNumber - 1) * 0x1008;
  lowLen = (uint)highLen;
  clusterNumber = (int)((ulonglong)highLen >> 32) + (uint)(0xffffffd7 < lowLen);
                    /* set to (clusterNumber - 1) * 0x1008 + 0x28 */
  SetFilePointer(hArchive,lowLen + 0x28,(PLONG)&clusterNumber,FILE_BEGIN);
  ok = ReadFile(hArchive,CLUSTER_BUFFER,0x1008,&bytesRead,(LPOVERLAPPED)NULL);
  if (ok == FALSE) {
    return (BYTE *)NULL;
  }
  clusterNumber = 0x1008;
  if (key != NULL) {
    ok = CryptDecrypt(key,0,TRUE,0,CLUSTER_BUFFER,&clusterNumber);
    if (ok == FALSE) {
      GetLastError();
      printf("ERROR: Unable to decrypt block from cluster %d.\n",clusterNo);
                    /* WARNING: Subroutine does not return */
      exit(1);
    }
  }
  return CLUSTER_BUFFER;
}
---CODE END---

p233, decompilation of 00401670 is rather messy, it checks if an archive file of the same base name
exists (extension is implicit wrt. cryptex CLI), if true checks the password stored in the archive,
if not it reports error or creates a new archive with the given password according to 3rd
(allowWrite?) and 4th (allowCreate?) parameters: In the extract scenario both 3rd and 4th parameters
are set to 0 (FALSE). Return value is a file handle to the archive file.

p228, decompilation of 0x00401BB0
--- CODE START---
/* WARNING: Could not reconcile some variable overlaps */

void __cdecl ExtractFileFromArchive(char *archivePath,char *fileName,HCRYPTKEY key)

{
  dword cookie_00;
  HANDLE hArchive;
  BOOL ok;
  DWORD fileCluster;
  char *pDirSep;
  int iVar1;
  int *piVar2;
  uint fileClusterCount;
  int *piVar3;
  bool bVar4;
  DWORD clusterNumber;
  HANDLE hOut;
  char *baseName;
  HCRYPTHASH hHash;
  float percentPerCluster;
  DWORD hashLen;
  DWORD DStack88;
  _CONSOLE_SCREEN_BUFFER_INFO screenInfo;
  _CONSOLE_SCREEN_BUFFER_INFO _Stack60;
  BYTE hashVal [16];
  BYTE fileHash [16];
  DWORD cookie;
  DWORD dataLen;
  float fClusterCount;
  
  cookie_00 = __security_cookie;
  hArchive = CheckArchivePasswordOrCreate(key,archivePath,FALSE,FALSE);
  ok = CryptCreateHash(CRYPT_PROVIDER,CALG_MD5,0,0,&hHash);
  if (ok == FALSE) {
    printf("Unable to verify the file\'s hash value!\n");
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  SetFilePointer(hArchive,0,(PLONG)NULL,FILE_BEGIN);
  ReadFile(hArchive,HEADER_BUFFER,0x28,(LPDWORD)&percentPerCluster,(LPOVERLAPPED)NULL);
                    /* initializing a struct? */
  fileHash._1_4_ = 0;
  fileHash._5_4_ = 0;
  fileHash._9_4_ = 0;
  fileHash._13_2_ = 0;
  clusterNumber = 0;
  hOut = fileName;
  fileHash[0] = '\0';
  fileHash[15] = '\0';
  fileCluster = LocateFile(hArchive,fileName,&clusterNumber,(DWORD *)fileHash,key);
  fileClusterCount = clusterNumber;
                    /* extract basename */
  baseName = fileName;
  pDirSep = strchr(fileName,L'\\');
  while (pDirSep != (char *)0x0) {
    baseName = pDirSep + 1;
    pDirSep = strchr(baseName,L'\\');
  }
  if (fileCluster == 0) {
    printf("File \"%s\" not found in archive.\n");
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
                    /* first parameter should be basename */
  hOut = CreateFileA((LPCSTR)hOut,GENERIC_READ | GENERIC_WRITE,0,(LPSECURITY_ATTRIBUTES)0x0,2,0,
                     (HANDLE)NULL);
  if (hOut == (HANDLE)INVALID_HANDLE_VALUE) {
    GetLastError();
    printf("ERROR: Unable to create file \"%s\" (Last Error=%d).\n");
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  DecryptCluster(hArchive,fileCluster,key);
  fClusterCount = (float)fileClusterCount;
  if ((int)fileClusterCount < 0) {
    fClusterCount = fClusterCount + 4.294967e+09;
  }
  percentPerCluster = 100.0 / fClusterCount;
  clusterNumber = 0;
  printf("Extracting \"%.35s\" - ",baseName);
  while (fileClusterCount != 0) {
    GetConsoleScreenBufferInfo(CONSOLE_SCREEN_BUFFER_HANDLE,&screenInfo);
    printf("%2.2f percent completed.");
                    /* the last cluster may not be full
                       cluster+0x0 is the actual data size of the cluster
                       a full cluster has 0xffc bytes of data
                       0x1008 - 0xffc = 12 bytes of header */
    dataLen = 0xffc;
    if (fileClusterCount < 2) {
      dataLen = CLUSTER_BUFFER._0_4_;
    }
    ok = CryptHashData(hHash,CLUSTER_BUFFER + 4,dataLen,0);
    if (ok == FALSE) {
      printf("Unable to verify the file\'s hash value!\n");
                    /* WARNING: Subroutine does not return */
      exit(1);
    }
    dataLen = 0xffc;
    if (fileClusterCount < 2) {
      dataLen = CLUSTER_BUFFER._0_4_;
    }
    WriteFile(hOut,CLUSTER_BUFFER + 4,dataLen,&DStack88,(LPOVERLAPPED)0x0);
    fileClusterCount = fileClusterCount - 1;
    if (fileClusterCount != 0) {
                    /* when not last cluster of a file, 0x0 is the pointer to the next cluster
                       otherwise 0x0 is the number of actual data size of the current cluster */       
      DecryptCluster(hArchive,CLUSTER_BUFFER._0_4_,key);
    }
                    /* update progress percentage after each cluster */
    GetConsoleScreenBufferInfo(CONSOLE_SCREEN_BUFFER_HANDLE,&_Stack60);
    SetConsoleCursorPosition(CONSOLE_SCREEN_BUFFER_HANDLE,screenInfo.dwCursorPosition);
    clusterNumber = (DWORD)((float)clusterNumber + percentPerCluster);
  }
  printf("%2.2f percent completed.");
  printf("\n");
  hashVal._1_4_ = 0;
  hashVal._5_4_ = 0;
  hashVal._9_4_ = 0;
  hashVal._13_2_ = 0;
  hashVal[15] = '\0';
  hashVal[0] = '\0';
  hashLen = 0x10;
  ok = CryptGetHashParam(hHash,HP_HASHVAL,hashVal,&hashLen,0);
  if (ok == FALSE) {
    printf("Unable to obtain MD5 hash value for file.\n");
  }
                    /* test fileHash == hashVal */
  iVar1 = 4;
  bVar4 = true;
  piVar2 = (int *)hashVal;
  piVar3 = (int *)fileHash;
  do {
    if (iVar1 == 0) break;
    iVar1 = iVar1 + -1;
    bVar4 = *piVar2 == *piVar3;
    piVar2 = piVar2 + 1;
    piVar3 = piVar3 + 1;
  } while (bVar4);
  if (!bVar4) {
    printf("ERROR: File \"%s\" is corrupted!\n");
  }
  CryptDestroyHash(hHash);
  CloseHandle(hOut);
  CloseHandle(hArchive);
  __security_check_cookie(cookie_00);
  return;
}
---CODE END---

Cryptex header:
    0x00:8      signature, "CrYpTeX9"
    0x08:2      ??, always 1
    0x0a:2      ??, always 0, maybe major and minor version number
    0x0c:4      first file list cluster index
    0x10:4      pointer to the head of the free cluster list
                00401290 is the function that allocates a new cluster
    0x14:4      the total number of clusters
    0x18:16     MD5 checksum of SHA hash of user password

Cryptex file list cluster:
    0x00:152*26 file entries

Cryptex file entry:
    0x00:4      next cluster index
    0x04:4      first data cluster
    0x08:4      total number of clusters used by this file
    0x0C:16     MD5 hash of the file
    0x1C:128    file name, null terminated

Crytex data cluster:
    0x00:4      next cluster index, or actual data size
    0x04:4      ??
    0x08:4      ??
    0x0c:4096   data

decompilation of 00401290:
---CODE START---
DWORD __cdecl AllocateNewCluster(HANDLE hArchive,HCRYPTKEY key)

{
  longlong lVar1;
  uint posLow;
  int i;
  int posHigh;
  DWORD freeCluster;
  undefined4 *pData;
  
  freeCluster = HEADER_BUFFER._16_4_;
  if (HEADER_BUFFER._16_4_ != 0) {
    DecryptCluster(hArchive,HEADER_BUFFER._16_4_,key);
                    /* remove one free cluster from the free cluster list */
    HEADER_BUFFER._16_4_ = CLUSTER_BUFFER._0_4_;
                    /* memset(CLUSTER_BUFFER + 4, 0, 8 + 4092) */
    pData = (undefined4 *)(CLUSTER_BUFFER + 4);
    for (i = 0x3ff; i != 0; i = i + -1) {
      *pData = 0;
      pData = pData + 1;
    }
    return freeCluster;
  }
                    /* total number of clusters += 1 */
  HEADER_BUFFER._20_4_ = HEADER_BUFFER._20_4_ + 1;
                    /* archive end = number of clusters * 0x1008 + 0x28 */
  posLow = (uint)((ulonglong)HEADER_BUFFER._20_4_ * 0x1008);
  posHigh = (int)((ulonglong)HEADER_BUFFER._20_4_ * 0x1008 >> 0x20) + (uint)(0xffffffd7 < posLow);
  SetFilePointer(hArchive,posLow + 0x28,&posHigh,0);
  SetEndOfFile(hArchive);
                    /* new cluster start = (number of clusters - 1) * 0x1008 + 0x28 */
  lVar1 = (ulonglong)(HEADER_BUFFER._20_4_ - 1) * 0x1008;
  posLow = (uint)lVar1;
  posHigh = (int)((ulonglong)lVar1 >> 0x20) + (uint)(0xffffffd7 < posLow);
  SetFilePointer(hArchive,posLow + 0x28,&posHigh,0);
                    /* memset(CLUSTER_BUFFER, 0, 12 + 4092) */
  pData = (undefined4 *)CLUSTER_BUFFER;
  for (i = 0x402; i != 0; i = i + -1) {
    *pData = 0;
    pData = pData + 1;
  }
  return HEADER_BUFFER._20_4_;
}
---CODE END---

7. Auditing Program Binaries
p243, JPEG example
just like air crashes, such a security breach could only be possible due to a cascade of unaccounted
errors on every level of the system: 
    - the operating system has no proper, fine-grained permission control
    - the programming language used by default doesn't bound check memory access
    - only finally, coding error by programmer of the JPEG library

p247, Chapter7!launch:
    00401060 mov eax,[esp+0x4]                  ; PARAM_1
    00401064 sub esp,0x64                       ; esp = -0x64, relative to return address
                                                ; stack state:
                                                ;   -0x64: char buffer[100]
                                                ;   -0x00: return address
    00401067 push eax                           ; PARAM_1, char *src
                                                ; esp = -0x68
    00401068 lea ecx,[esp+0x4]                  ; ecx = buffer (-0x64)
    0040106c push ecx                           ; buffer, char *dest
                                                ; esp = -0x6C
    0040106d call Chapter7!strcpy (00401180)    
    00401072 lea edx,[esp+0x8]                  ; edx = buffer (-0x64)
    00401076 push 0x408128                      ; some string literal, char *src
                                                ; esp = -0x70
    0040107b push edx                           ; buffer, char *dest
                                                ; esp = -0x74
    0040107c call Chapter7!strcat (00401190)
    00401081 lea eax,[esp+0x10]                 ; buffer (-0x64)
    00401085 push eax                           ; buffer, char *command
                                                ; esp = -0x78
    00401086 call Chapter7!system (004010e7)
    0040108b add esp,0x78                       ; esp = 0
    0040108e ret

p250, Chapter7!launch:
    00401060 mov eax,[esp+0x4]                  ; eax = PARAM_1
    00401064 lea edx,[esp-0x64]                 ; edx = buffer
    00401068 sub esp,0x64
    0040106b sub edx,eax                        ; edx = buffer - &PARAM_1
                                                ; i = 0
    0040106d lea ecx,[ecx]                      ; ecx = ecx? maybe padding
strcpy:
    00401070 mov cl,[eax]                       ; cl = PARAM_1[i]
    00401072 mov [edx+eax],cl                   ; buffer[i] = PARAM_1[i]
    00401075 inc eax                            ; i += 1
    00401076 test cl,cl                         ; if (PARAM_1[i] != '\0')
    00401078 jnz Chapter7!launch+0x10 (00401070);   jump to strcpy
    0040107a push edi
    0040107b lea edi,[esp+0x4]
    0040107f dec edi                            ; i = -1
strcat:
    00401080 mov al,[edi+0x1]                           ; al = buffer[i + 1] 
    00401083 inc edi                                    ; i += 1;
    00401084 test al,al                                 ; if (buffer[i] != '\0')
    00401086 jnz Chapter7!launch+0x20 (00401080)        ;   jump to strcat
    00401088 mov eax,[Chapter7!'stringâ€™ (00408128)]     ; eax = string[0..4] as DWORD
    0040108d mov cl,[Chapter7!'stringâ€™+0x4 (0040812c)]  ; cl = string[4]
                                                        ; string is 5-chars long
    00401093 lea edx,[esp+0x4]                          ; edx = buffer
    00401097 mov [edi],eax                              ; buffer[i..i+4] = string[0..4]
    00401099 push edx                                   ; buffer, char *command
    0040109a mov [edi+0x4],cl                           ; buffer[i+4] = string[i+4]
    0040109d call Chapter7!system (00401102)
    004010a2 add esp,0x4                                ; epilogue
    004010a5 pop edi
    004010a6 add esp,0x64
    004010a9 ret

p258, allocate_object:
    00401021 push esi                                   ; esp = -0x4, relative to origin
    00401022 push edi                                   ; esp = -0x8
    00401023 mov edi,[esp+0x10]                         ; edi = PARAM_2 (+0x8)
    00401027 lea esi,[edi+0x18]                         ; esi = PARAM_2 + 0x18
    0040102a push esi                                   ; PARAM_2 + 0x18, size_t size
    0040102b call Chapter7!malloc (004010d8)
    00401030 pop ecx
    00401031 xor ecx,ecx                                ; ecx = 0
    00401033 cmp eax,ecx                                ; if (eax != NULL)
    00401035 jnz Chapter7!allocate_object+0x1a (0040103b)   ;   jump to malloc_ok
    00401037 xor eax,eax                                ; return NULL
    00401039 jmp Chapter7!allocate_object+0x42 (00401063)
malloc_ok:
    0040103b mov [eax+0x4],ecx                          ; memset(eax, 0, 0x18)
    0040103e mov [eax+0x8],ecx
    00401041 mov [eax+0xc],ecx
    00401044 mov [eax+0x10],ecx
    00401047 mov [eax+0x14],ecx
    0040104a mov ecx,edi                                ; ecx = PARAM_2
    0040104c mov edx,ecx                                ; edx = PARAM_2
    0040104e mov [eax],esi                              ; *eax = PARAM_2 + 0x18
                                                        ; first 4 bytes in header is length
                                                        ; memcpy(PARAM_1, eax + 0x18, PARAM_1, PARAM_2)
    00401050 mov esi,[esp+0xc]                          ; esi = PARAM_1 (+0x4)
    00401054 shr ecx,0x2                                ; ecx = PARAM_2 / 4
    00401057 lea edi,[eax+0x18]                         ; edi = eax + 0x18
    0040105a rep movsd                                  ; PARAM_2 bytes copied from PARAM_1 to eax
                                                        ; 4 bytes at a time
    0040105c mov ecx,edx                                ; edx = PARAM_2
    0040105e and ecx,0x3                                ; edx = PARAM_2 % 4
    00401061 rep movsb                                  ; copy reminders
exit:
    00401063 pop edi 
    00401064 pop esi
    00401065 ret

p262, the original analysis of Code Red by eEye:
http://web.archive.org/web/20081226021124/http://research.eeye.com/html/advisories/published/AL20010717.html
the initial infection vector 
    GET /default.ida?NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN%u9090%u6858%ucbd3%u7801%u9090%u6858%ucbd3%u7801%u9090%u6858%ucbd3%u7801%u9090%u9090%u8190%u00c3%u0003%u8b00%u531b%u53ff%u0078%u0000%u00=a  HTTP/1.0
overwrites the stack with 
    4E 00 4E 00 4E 00 4E 00
    4E 00 4E 00 4E 00 4E 00
    4E 00 4E 00 4E 00 4E 00
    92 90 58 68 4E 00 4E 00
    4E 00 4E 00 4E 00 4E 00
    FA 00 00 00 90 90 58 68
    D3 CB 01 78 90 90 58 68
    D3 CB 01 78 90 90 58 68
    D3 CB 01 78 90 90 90 90
    90 81 C3 00 03 00 00 8B
    1B 53 FF 53 78
where the address to exception handler is overwritten by 7801CBD3, which is an address in msvcrt.dll
that reads:
    call ebx
the code flow is then redirected to the stack, then to the worm payload in the HTTP request body.

p267, void __stdcall DecodeURLEscapes(
    // [in] encoded ascii url
    unsigned char *url,
    // [in, out?] length of ascii url
    unsigned long &urlLen,
    // [out] decoded, unescaped utf-16 url
    unsigned WCHAR *decoded,
    // +0x8 of EXTENSION_CONTROL_BLOCK
    // https://learn.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms525658(v=vs.90)
    // [in] a unique number assigned by the HTTP server
    HCONN connID,
)

8. Reversing Malware
p278, Information-Stealing Worms: better known as ransomware, since 2017 surged in popularity
because of cryptocurrency as an anonymous method of global payment. 

p279, BIOS/Firmware Malware, Intel ME, a backdoor on modern Intel platforms, allegedly planted by
Intel instructed by NSA, runs in ring -3 under the kernel and the CPU, has full access to the
memory, the network stack and any type of peripherals (keyboard, mouse, display etc.), (until the
recent discovery of an undocumented configuration for government agencies) cannot be disabled by
users, cannot even be turned off as long as the computer is plugged in. A similar firmware backdoor
was discovered on AMD platforms well. 
Another group of kernel-level malware that people willingly install on their system is anti-cheat
software. Despite their name these softwares seldomly prevented cheats to a perceivable degree,
instead they frequently are closed-source, introduce vulnerabilities to the system and in rare cases
have embedded crypto miners.

Polymorphism: 
    - encrypt / decrypt the malware with random keys each time it's replicated
    - randomize registers each time the malware is decrypted

Metamorphism:
    - rearrange registers, instructions, functions, insert garbage in between, reverse branches
    - basically a decompiler and a randomizing compiler combined

p291, The Initial Installation
DWORD GetModuleFileNameA(
    // when NULL, retrieves the executable path of the current process
    [in, optional] HMODULE hModule,
    [out]          LPSTR   lpFilename,
    // size of lpFilename buffer
    [in]           DWORD   nSize
);
DWORD CharUpperBuffA(
    // converts lower case characters to upper case, according to the system locale
    // which means lpsz is not treated as ascii nor unicode but anything in between
    // also in unicode there's no guarantee the upper case character has the same byte length as the
    // lower case character, hence the function doesn't work with unicode
    [in, out] LPSTR lpsz,
    // size of lpsz
    [in]      DWORD cchLength
);
// creates or _opens_ a named mutex
HANDLE CreateMutexA(
    [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes,
    // ignored if named mutex exists
    [in]           BOOL                  bInitialOwner,
    [in, optional] LPCSTR                lpName
);
...
    004026CE MOV EDI,0                      ; retry = 0
    004026D3 JMP SHORT ZoneLock.004026E0    ; jump to copy_to_system_dir
sleep_before_retry:
    004026D5 PUSH 1F4                       ; Timeout = 500. ms
    004026DA CALL <JMP.&KERNEL32.Sleep>
    004026DF INC EDI
copy_to_system_dir:
    004026E0 PUSH 0 ; FailIfExists = FALSE
    004026E2 PUSH ZoneLock.00404010         ; NewFileName = â€œC:\WINNT\system32\ZoneLockup.exeâ€
    004026E7 PUSH ZoneLock.00404540         ; ExistingFileName = â€œC:\WINNT\SYSTEM32\ZoneLockup.exeâ€
    004026EC CALL <JMP.&KERNEL32.CopyFileA>
    004026F1 OR EAX,EAX
    004026F3 JNZ SHORT ZoneLock.004026FA
    004026F5 CMP EDI,5                      ; the operation is retried at most 5 times
    004026F8 JL SHORT ZoneLock.004026D5     ; jump to sleep_before_retry
...
    00402760 PUSH 7D0                       ; Timeout = 2000. ms  
    00402765 CALL <JMP.&KERNEL32.Sleep>     ; wait for the main process to exit
    0040276A MOV EAX,ESI
    0040276C ADD EAX,4
    0040276F PUSH EAX                       ; FileName
    00402770 CALL <JMP.&KERNEL32.DeleteFileA>
...
    0040277E CALL <JMP.&KERNEL32.CreateMutexA> 
    00402783 MOV DWORD PTR DS:[404650],EAX
    00402788 CALL <JMP.&KERNEL32.GetLastError>  
    0040278D CMP EAX,0B7                        ; ERROR_ALREADY_EXISTS
                                                ; system objects in windows share the same namespace,
                                                ; if another non-mutex object by the same name
                                                ; exists, ERROR_ALREADY_EXISTS is set
                                                ; this should be an easy switch to kill this trojan
    00402792 JNZ SHORT ZoneLock.0040279B
    00402794 PUSH 0 ; ExitCode = 0
    00402796 CALL <JMP.&KERNEL32.ExitProcess>

p294, Initializing Communications
BOOL InternetGetConnectedState(
    // connection description
    [out] LPDWORD lpdwFlags,
    // must be 0
    [in]  DWORD   dwReserved
);

p300,
    00402EED XOR EDI,EDI                        ; i = 0
loop:
    00402EEF LEA EAX,DWORD PTR SS:[EBP-60]      ; s2 = EBP-0x60
    00402EF2 PUSH EAX                           ; s2, char *str2
    00402EF3 IMUL EAX,EDI,50
    00402EF6 LEA EAX,DWORD PTR DS:[EAX+4051C5]  ; s1 = NAME_TABLE + i * 50
    00402EFD PUSH EAX                           ; s1, char *str1
    00402EFE CALL <JMP.&CRTDLL.strcmp> ; strcmp ; ord = strcmp(s1, s2)
    00402F03 ADD ESP,8                          
    00402F06 OR EAX,EAX                         ; if (ord != 0)
    00402F08 JNZ SHORT ZoneLock.00402F0D        ;   jump to not_equal
    00402F0A XOR EBX,EBX
    00402F0C INC EBX                            ; found = TRUE
not_equal:
    00402F0D INC EDI                            ; i += 1
    00402F0E CMP EDI,3                          ; if (i <= 3)
    00402F11 JLE SHORT ZoneLock.00402EEF        ;   jump to loop

9. Piracy and Copy Protection
p312, among today's major operating systems, iOS is the obvious one that doesn't qualify as an open
architecture: all applications must be signed with a known Apple developer key otherwise iOS will
refuse to load the executable. Any modification to the application will invalid the signature.
There's no easy way for iOS users to bypass the check as they usually do not have root access to the
OS: they do not actually own the device they purchased.

p323, LeGrande Technology, later rebranded as Intel Trusted Execution Technology (Intel TXT),
hashes code / memory at every boot step in help of a Trusted Platform Module (TPM) providing save
memory region inaccessible to kernel / user code, to determine if any part of the BIOS or operating
system has been modified therefore defends them against software attack.

p323, NGSCB is scaled back and eventually cancelled / absorbed by other project inside Microsoft,
only BitLocker, a part of the original NGSCB, was shipped with Windows Vista in 2006. BitLocker is a
full-volume encryption tool that encrypts entire disk partition with keys secured by TPM protected
memory region.